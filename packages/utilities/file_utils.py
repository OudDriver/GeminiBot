from __future__ import annotations

import asyncio
import json
import logging
import time
import wave
from pathlib import Path
from typing import TYPE_CHECKING

from packages.utilities.errors import HandleAttachmentError
from packages.utilities.general_utils import generate_unique_file_name

if TYPE_CHECKING:
    import discord
    from google.genai import Client
    from google.genai.types import File


logger = logging.getLogger(__name__)

def check_for_file_active(uploaded_file: File) -> bool:
    """Check if the uploaded file is active on Google servers."""
    status = uploaded_file.state
    return status == "ACTIVE"


async def wait_for_file_active(uploaded_file_to_check: File) -> None:
    """Wait until the uploaded file becomes active on Google servers."""
    start_time = time.monotonic()
    timeout = 30

    try:
        while not check_for_file_active(uploaded_file_to_check):
            if time.monotonic() - start_time >= timeout:
                logger.warning(
                    f"Timeout while waiting for file {uploaded_file_to_check.name} "
                    f"to become active. Skipping Check.",
                )
                return

            await asyncio.sleep(1)

    except Exception:
        logger.exception("Error while waiting for file active!")


async def handle_attachment(
        attachment: discord.Attachment,
        client: Client,
) -> tuple[list[str], list[File]]:
    """Handle a discord.Attachment and uploads them to Google."""
    file_name = ""
    try:
        file_extension = attachment.filename.split(".")[-1]
        unique_file_name = generate_unique_file_name(file_extension)
        file_name = f"./temp/{unique_file_name}"

        await attachment.save(Path(file_name))
        logger.info(f"Saved {attachment.content_type.split('/')[0]} {file_name}")

        file_names = []
        uploaded_files = []

        file_names.append(file_name)
        uploaded_file = await asyncio.to_thread(client.files.upload, file=file_name)
        uploaded_files.append(uploaded_file)

        logger.info(f"Uploaded {uploaded_file.display_name} as {uploaded_file.name}")

        return file_names, uploaded_files
    except Exception as e:
        logger.exception("Error when trying to handle attachments.")
        raise HandleAttachmentError(file_name) from e


def save_temp_config(
    model: str | None = None,
    system_prompt_data: str | None = None,
    current_uwu_status: bool | None = None,
    thought: list | None = None,
    secret: list | str | None = None,
    tool_use: dict | None = None,
    thinking: bool | None = None,
    thinking_budget: int | None = None,
) -> None:
    """Save the current configuration to temp_config.json.

    If an argument is None, uses the existing value from the file (if it exists).
    For the 'secret' argument, if a value is provided, it appends it to the
    existing list of secrets (or creates a new list if none exists).

    Args:
        model: The model to use.
        system_prompt_data: The system prompt to use.
        current_uwu_status: Whether if uwu mode is on or off.
        thought: The thought generated by non-thinking models.
                 May be deprecated if Google decided to include thinking to all models.
        secret: The secret to keep.
        tool_use: The tool use to append.
        thinking: Whether for new models (such as Gemini 2.5 Flash Preview 04-17)
                  to think or not.
        thinking_budget: The thinking budget.
    """
    temp_config_path = "temp/temp_config.json"

    existing_config = read_temp_config()

    new_config = {
        "model": model if model is not None else existing_config.get("model", None),
        "system_prompt": system_prompt_data
        if system_prompt_data is not None
        else existing_config.get("system_prompt", None),
        "uwu": current_uwu_status
        if current_uwu_status is not None
        else existing_config.get("uwu", None),
        "thought": thought
        if thought is not None
        else existing_config.get("thought", None),
        "secret": [],
        "tools_history": [],
        "thinking": thinking if thinking else existing_config.get("thinking", None),
        "thinking_budget": thinking_budget
        if thinking_budget
        else existing_config.get("thinking_budget", None),
    }

    if secret is not None:
        existing_secrets = existing_config.get(
            "secret", [],
        )
        if isinstance(existing_secrets, list):
            new_config["secret"] = _append_secret(existing_secrets, secret)
    else:
        new_config["secret"] = existing_config.get("secret", None)

        if secret is not None:
            existing_secrets = existing_config.get(
                "secret", [],
            )
            if isinstance(existing_secrets, list):
                new_config["secret"] = _append_secret(existing_secrets, secret)
        else:
            new_config["secret"] = existing_config.get("secret", None)

    if tool_use is not None:
        if tool_use != {}:
            existing_history = existing_config.get("tools_history", [])
            if isinstance(existing_history, list):
                new_config["tools_history"].append(tool_use)
            else:
                new_config["tools_history"] = [tool_use]
        else:
            new_config["tools_history"] = []

    else:
        new_config["tools_history"] = existing_config.get("tools_history", None)

    with open(temp_config_path, "w") as f:
        json.dump(new_config, f)


def _append_secret(existing_secrets: list, secret: list | str) -> list:
    if isinstance(secret, list):
        return existing_secrets + secret
    return [*existing_secrets, secret]


def read_temp_config() -> dict:
    """Reads the configuration from temp/temp_config.json.

    Returns:
        dict: A dictionary containing the configuration, or an empty dictionary
              if the file doesn't exist or contains invalid JSON.
    """
    temp_config_path = "temp/temp_config.json"

    try:
        with open(temp_config_path) as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        logger.exception("File cannot be found or JSON syntax is invalid!")
        return {}  # Return an empty dictionary if the file is missing or invalid


def load_config() -> dict[str, str | float]:
    """Load the configuration from config.json."""
    with open("config.json") as f:
        return json.load(f)


def validate_config_files() -> bool:
    """Validates if the required keys are present in the config file.

    Checks for the existence of essential configuration keys. If the file
    is missing or if any required key is not found in the loaded config,
    it logs an error detailing the issue.

    Returns:
        True if the config file exists and contains all required keys
        and their types are correct.
        Otherwise, False.
    """
    required_keys = {
        "GeminiAPIkey": str,
        "DiscordToken": str,
        "OwnerID": str,
        "ModelNames": dict,
        "SystemPrompts": list,
        "HarmBlockThreshold": str,
        "Temperature": float,
    }

    try:
        config = load_config()

        missing_keys = []
        for key, value in required_keys.items():
            if key not in config or not isinstance(config[key], value):
                missing_keys.append(key)

        if missing_keys:
            # Report all missing keys at once
            logger.error(
                f"Config validation failed. File 'config.json' is missing "
                f"the following required key(s) or the types"
                f"are invalid: {', '.join(missing_keys)}",
            )
            return False
        return True

    except FileNotFoundError:
        # Log specifically that the file is missing
        logger.exception(
            "Config file 'config.json' not found. "
            "Please ensure it exists and is correctly named.",
        )
        return False
    except json.JSONDecodeError:
        logger.exception(
            "Config validation failed "
            "because 'config.json' could not be parsed (invalid JSON).",
        )
        return False
    except Exception:
        logger.exception("An unexpected error occurred during config validation.")
        return False


def save_wave_file(
    filename: str,
    pcm: bytes,
    channels: int = 1,
    rate: int = 24000,
    sample_width: int = 2,
) -> None:
    """Saves PCM audio data to a WAVE file.

    Args:
        filename: The name of the file to save the audio to.
        pcm: The PCM audio data as bytes.
        channels: The number of audio channels (e.g., 1 for mono, 2 for stereo).
                  Defaults to 1.
        rate: The sampling rate in Hz (frames per second). Defaults to 2400.
        sample_width: The sample width in bytes (e.g., 2 for 16-bit audio).
                      Defaults to 2.
    """
    with wave.open(filename, "wb") as wf:
        wf.setnchannels(channels)
        wf.setsampwidth(sample_width)
        wf.setframerate(rate)
        wf.writeframes(pcm)
